The drawing command is controlled by a print record
-> this has to be easy to understand as the user should be able to read, understand and modify it
-> it consists of several subrecords in which different data can be stored
-> it is possible to customize the drawing method and additional subrecords can be defined to help that goal
-> essential record: drawingOrder [this is the main structure of the drawing method and can not be modified]
-> essential record: coordinates [of vertices, edges, faces]
-> essential record: metricData [to store lengths and angles]
-> essential record: drawingStyle [to choose the styles and depictions in the drawing]

At the start the print record has to be initialized. Mods may introduce additional entries here.
At the end these aditional entries have to removed again. Therefore we need an initialization
and a cleanup method. 
    PrintRecordDrawingOrderInit( rec )
    PrintRecordDrawingOrderCleanup( rec )

Mods will be part of a set containing a function of each type (?).
The essential components should be handled similarly (for consistency). (For each subrecord one set)
Then it is also easier to swap some of them (like the default metric data handler) for a mod.

Main loop (drawing via edges):
    1) Take a face that is not yet printed. If there are none, finished
    2) Print it, save uncompleted vertices and edges
    3) Find new edge to continue on
    4) Compute adjacent face
    5) Check if new face is ok here. If no, go back to (3). If all edges are rejected, continue with the first rejected one.
    6) Print new face, save uncompleted vertices and edges
    7) If no more edges are uncompleted, go back to (1)

Necessary entries:
1) printedFaces (can be deduced from coordinates!faces but it can also be put into drawingOrder to encapsulate information)
2) drawingOrder!openVertices and drawingOrder!openEdges
        Convention: store edge coordinates in an order such that the orientation of the yet unprinted face, that is induced by this order
        is positive (counter-clockwise).
    PrintRecordMetricDataComputeFace( rec, complex, face, edge, edgePos ) -> vertex-edge-path starting with first vertex of edge, as pairs [vertex, coordList] or just edge number
    PrintRecordMetricDataComputeFace( rec, complex, face ) -> same but with starting face

    PrintRecordCoordinatesRecognizeVertices( rec, vertexEdgePath ) -> Returns a list of the same length as path. If the vertex/edge was new, the entry is not bound. Otherwise the position in the appropriate list is set here.
    PrintRecordCoordinatesIntersection( rec, vertexEdgePath, recognized ) -> Returns true or false
    PrintRecordCoordinatesAddFace( rec, vertexEdgePath, recognized )   ---- after calling, openVertices and openEdges have to be modified

3) for determination of next edge there is a list of pairs [function, number] - the function is called at most number times (infinity is permitted) to determine
    which edge is the next one. If one is found but rejected by tests (also given by list of functions) the next one is tried. If tests reject all edges, the first edge
    that had been proposed is chosen instead. A function may return fail to signal that it did not find anything. Then the next element in the list is called.

    PrintRecordDrawingOrderNextGivenEdge( rec, forbiddenEdges )
