The drawing command is controlled by a print record
-> this has to be easy to understand as the user should be able to read, understand and modify it
-> it consists of several subrecords in which different data can be stored
-> it is possible to customize the drawing method and additional subrecords can be defined to help that goal
-> essential record: drawingOrder [this is the main structure of the drawing method and can not be modified]
-> essential record: coordinates [of vertices, edges, faces]
-> essential record: metricData [to store lengths and angles]
-> essential record: drawingStyle [to choose the styles and depictions in the drawing]

At the start the print record has to be initialized. Mods may introduce additional entries here.
At the end these aditional entries have to removed again. Therefore we need an initialization
and a cleanup method. 
    PrintRecordDrawingOrderInit( rec )
    PrintRecordDrawingOrderCleanup( rec )

Mods will be part of a set containing a function of each type (?).
The essential components should be handled similarly (for consistency). (For each subrecord one set)
Then it is also easier to swap some of them (like the default metric data handler) for a mod.

Main loop (drawing via edges):
    1) Take a face that is not yet printed. If there are none, finished
    2) Print it, save uncompleted vertices and edges
    3) Find new edge to continue on
    4) Compute adjacent face
    5) Check if new face is ok here. If no, go back to (3). If all edges are rejected, continue with the first rejected one.
    6) Print new face, save uncompleted vertices and edges
    7) If no more edges are uncompleted, go back to (1)

Necessary entries:
1) printedFaces (can be deduced from coordinates!faces but it can also be put into drawingOrder to encapsulate information)
2) drawingOrder!openVertices and drawingOrder!openEdges
        Convention: store edge coordinates in an order such that the orientation of the yet unprinted face, that is induced by this order
        is positive (counter-clockwise).
    PrintRecordMetricDataComputeFace( rec, complex, face, edge, edgePos ) -> vertex-edge-path starting with first vertex of edge, as pairs [vertex, coordList] or just edge number
    PrintRecordMetricDataComputeFace( rec, complex, face ) -> same but with starting face

    PrintRecordCoordinatesRecognizeVertices( rec, vertexEdgePath ) -> Returns a list of the same length as path. If the vertex/edge was new, the entry is not bound. Otherwise the position in the appropriate list is set here.
    PrintRecordCoordinatesIntersection( rec, vertexEdgePath, recognized, lastData ) -> Returns true or false
    PrintRecordCoordinatesAddFace( rec, vertexEdgePath, recognized )   ---- after calling, openVertices and openEdges have to be modified

3) for determination of next edge there is a list of pairs [function, number] - the function is called at most number times (infinity is permitted) to determine
    which edge is the next one. If one is found but rejected by tests (also given by list of functions) the next one is tried. If tests reject all edges, the first edge
    that had been proposed is chosen instead. A function may return fail to signal that it did not find anything. Then the next element in the list is called.
    Problem: 
    a) change of internal parameters dangerous -> methods should not change internal parameters
    b) multiple computations
        b) can be alleviated by storing the coordinate results for each face computation (list by edges to make unbinding easier)
        b) needs also storing of the intersection results (with certain faces?) -> need additional parameter: Each check will return a list [true/false, data],
            where the data stores some (private) information about the test. In future tests, this data is an additional parameter. If the result of the test can
            be determined from this parameter alone, it does not have to be repeated. If the result of the test only depends on some additional stuff (like intersection
            testing does - you don't have to check all edges again, only the newly added ones), only the additional stuff has to be tested.

    PrintRecordDrawingOrderNextEdgeByGivenList( rec, forbiddenEdges )
    PrintRecordDrawingOrderNextEdgeByFirstOpenVertex( rec, forbiddenEdges )
    PrintRecordDrawingOrderNextEdgeByRandom( rec, forbiddenEdges )
    PrintRecordDrawingOrderNextEdgeByLastFace( rec, forbiddenEdges )
    PrintRecordDrawingOrderNextEdgeBySmallestIndex( rec, forbiddenEdges )

    -> store drawingOrder!printOrder: list of [dim, number, pos] to store which vertices/edges/faces were added in which order


In case of colouring, we replace MetricData by Colouring.

To draw the surface into tikz, we need
    PrintRecordDrawingStyleTikzVertex( rec, complex, vertex, tikzCoord )
    PrintRecordDrawingStyleTikzEdge( rec, complex, edge, tikzCoords )
    PrintRecordDrawingStyleTikzFace( rec, complex, edge, tikzCoords )
    (note that the vertex coordinates were transformed into tikz coordinates before)
    for the global styles: PrintRecordDrawingStyleGlobalStyles( rec, complex )
    have some options: vertexLabels, edgeLabels, faceLabels, colours, scale etc. -> should only produce one change in tex-file (for easier manual change, just in case)
    -> should be similar to "standard"-files [make TikZ-Header the default option?]
    -> allow string as "custom header-part"



For drawing order:
    Init
    Cleanup
    StartingFace
    NextEdge*
    GeneralMethod ?

For drawing style:
    Init
    Cleanup
    Tikz*
    GlobalStyles

For metric data:
    Init
    Cleanup
    ComputeFace

For coordinates:
    Init
    Cleanup
    Intersection
    AddFace

For colouring
    Init
    Cleanup
    ComputeFace
