
DisjointUnion(complex1, complex2, [optional: shift])
    -> Return [complex, shift]
    -> Apply uniform shift to all labels
    -> If given shift is larger than necessary, use it (otherwise as large as necessary)

----------------------------------------------------------------------

JoinVertices(complex, v1, v2)
    -> Return [complex, new vertex]
    -> If this is not possible (edge between them), fail is returned 
JoinVertices(complex1, v1, complex2, v2, [optional: shift])
    -> Return [complex, new vertex, shift]
    -> Combination of DisjointUnion and then JoinVertices (with shifted v2)


JoinEdges(complex, e1, e2)
    -> Return [complex, new edge]
    -> The edges should have been in an edge anomaly


JoinVertexEdgePaths(complex, path1, path2)
    -> Combination, as above
JoinVertexEdgePaths(complex1, path1, complex2, path2, optional:shift)
    -> return [complex, new path, shift]
    -> shift second complex, then join
    -> return the vePath that connects the two components


JoinPerimeters(complex, path1, path2)
    -> if the paths are not complete, they will be completed to the full perimeter
    -> can also be given as [vertex, edge] or [edge, edge] or [vertex,vertex] if that specifies the perimeter uniquely
    -> return fail if it is not possible (internally)
    -> Error if perimeters have different length
