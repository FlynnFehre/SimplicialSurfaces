Plan for the documentation of the package.

General goals:
1) Readability (it should not be very hard to read)
2) It should not be necessary to understand the structure of the manual to understand the concepts.
3) Navigation to related topics should be very easy and intuitive.
4) The manual should be strongly modular.
5) The manual should give good terminal support (if called with ??)

For concreteness we employ several test-users as benchmarks:
Technician: Wants to know how to apply an obscure function in full generality.
Worker: Wants to use an elementary method but forgot the exact procedure. Wants an answer shortly.
Searcher: Doesn't know the package, searches for a functionality and wants to know if the package can provide it.
Perfectionist: Wants to understand the package and its functionality completely.
Casual: Wants to get a general perspective but doesn't want to invest too much time.

TODO: General problem: If someone goes into a chapter that is confusing/technical/complicated, they MIGHT skip it or go back.
    But they also might be frustrated and leave. How can we make it clear that they don't have to get frustrated?

First chapter:
Goal: Teaser for the package, show capabilities (S), pique interest (C), give framework (P)
Name: What can it do?
Content:
The SimplicialSurface-package contains this basic functionality:
1) Working with simplicial surfaces [Link to generic introduction] (and generalizations of that [Link to that]), for example:
    <Pictures of polygonal surfaces. Take care to have a diverse sample. Currently:
        - Tetrahedron (Triangle, closed, surface, oriented)
        - four triangles (Triangle, not closed, surface, oriented)
        - three triangles at one edge (Triangle, not closed, ramified)
        - Tetrahedron with triangle at one edge (Triangle, ramified)
        - Two pairs of triangles (connected by edge) that are connected by vertex (butterfly)
        - open cone (from two triangles) (Triangle, open, Anomalies)
        - a surface from non-triangle shapes (even mixed)
    >
2) Working with edge colourings for simplicial surfaces (for the purpose of an embedding)
3) Treatment of folding and unfolding for these objects.
    <Picture of a folding step in a simple example>
    TODO: make abstract nature clear


Second chapter
Goal: Teaser. Show actual examples with code. Keep people interested, don't ramp up the complexity too much.
[We will first do an example without knowing internal properties of the surface and only afterwards add this complexity]
Name: Playing with simplicial surfaces, "Getting started" (if so, add LoadPackage and refer to the installation part if applicable)
Content:
Since the platonic solids are pre-defined [gives user some test-cases for experimenting] we use them to show the capabilities of this package.
    <Use cube (as it is known to more people than the other platonic solids and is quite small)>
    <Draw a picture and show the GAP-command Cube(), to avoid complicated constructors at the start>
We can compute elementary properties of the surface
    NrOfVertices
    NrOfEdges
    NrOfFaces
    EulerCharacteristic
and we can also show that the surface is homeomorphic to a sphere:
    IsClosedSurface
    IsConnected
    IsOrientable
    
We can also answer some more difficult questions like AutomorphismGroup or test for isomorphism (with one of the other platonic solids)
[TODO it is probably useful to show some capabilities. At the same time some users might be turned off if we linger too long on these
cases. We can do a list-style enumeration but this can run into the problem of being too long]


Third chapter
Goal: Motivate people to think about surfaces and constructors. Start easy (VerticesInFaces) and stay slow.
Name: Constructing some surfaces
Content:
Usually one is not interested in the properties of some platonic solids (usually you already know a lot about them).
Therefore we need a way to input our objects of interest into the package. 
As a test case we consider three triangles that are connected by egdes, like this:
    <picture>
An easy way to describe this information is to label faces and vertices. In our case each triangle is determined by its three vertices.
For example, the face I consists of the vertices [1,2,3] and the face III has the vertices [3,4,5]. From this information we can construct the simplicial complex:
    SimplicialSurfaceByVerticesInFaces( [[1,2,3],[2,3,4],[3,4,5]] );;
that retains this information
    VerticesInFaces( surf );

We can use this constructor to define a moebius strip <TODO with picture>
    IsOrientable( moebius );


    Subsection (relatively smaller font): Non-triangular faces
    Goal: Teach about non-triangular faces. This section should be easy to skip.
    [TODO: How can we make this easy to skip? How do people skip? When do people skip? Some people might read this as contrast to the triangular faces or to better understand the simpler material. Give those people something, but not very much (to encourage skipping).]
    If we want to have surfaces with non-triangular faces, the constructor SimplicialSurfacesByVerticesInFaces needs a bit more information. We consider the example of a pyramid with square base.
        <picture>
    As before, we label the vertices and faces first <top is 1, then label the other ones in a non-cyclic order>. If we now try to input the surface
    <do so>
    we notice something strange. Namely, the constructed surface is not closed
    <show this>
    The problem lies in the definition of the square face since it is not clear what the edges should be. For triangles every pair of vertices defines an edge, but for squares this is not the case. 
    The constructor of ... will believe, that two adjecent elements in the given list are connected by an edge. So <explain what went wrong concretely>. Instead we have to give the vertices in a cyclical order, like
    <do it correctly>

Fourth chapter
Goal: Learn about capabilities if we ignore the edge information (only constructor is ByVerticesInFaces)
Name: Playing with vertices and faces
Content:
After having learned how to construct a simplicial surface by SSByVerticesInFaces, we can use the indices on vertices and faces to get more detailed information about the surface. We will use the example surface from section <Link>
    <labelled picture of the three triangles (side by side)>
    <GAP-code to define this surface>
Most apparently we can reclaim the index information.
    Vertices(surf)
    Faces(surf)
    VerticesOfFaces(surf)
By using the index-structure we can distinguish vertices with different numbers of incident faces.
    UnsortedDegrees(surf)
If we want to have more detailed information about which faces are incident to a given vertex, we can use
    FacesOfVertices(surf)
An additional advantage of the indexial information is that we can determine a concrete global orientation if the surface is orientable.
    GlobalOrientation(surf)
If we want this orientation as list (instead of the permutation (1,3,2) the list [1,3,2]), we can use [Link to detailed discussion]
    GlobalOrientationByVerticesAsList(surf).

Fifth chapter
Goal: Learn about edge numbering and show additional capabilities.
Name: Adding edge numbering
Content:
Up until now we never cared about specific edges because they were not important for the construction of our examples so far. But let's assume we want to know which edges are incident to exactly two faces in our example from before [three faces in line].
    <picture>
    <GAP constructor>
We can see the edges by calling
    Edges(surf)
but this does not tell us where they are. For that we may use
    VerticesOfEdges(surf)
As before, the first entry of this list contains the vertices of the first edge. In our example the edge with number 1 is incident to the vertices ... . We can update our picture:
    <picture, with vertex and edge names>
If we now want to know which edges are incident to exactly two faces, we only have to check
    FacesOfEdges(surf)
The positions with lists of two elements are the interesting edges. We can compute them easily by
    Filtered( Edges(surf), e -> Size(FacesOfEdges(surf)[e]) = 2 );

Sixth chapter
Goal: Learn general constructors (downward incidence)
Name: Constructors with vertex, edge and face data
Content:
There are some cases in which we don't want to use ..VerticesInFaces but a more powerful method, for example
    1) The labelling is not arbitrary and we want to keep the given incidences
    2) The faces in our surface are not determined by their vertices
An example of the second situation is given by two triangles that share exactly two edges. They can be visualized as an 'open bag'
    <picture>
Since both faces share the same vertices, we can't use ..VerticesInFaces here. Instead we need to label vertices, edges and faces
    <do so in the picture, maybe using different colours and fonts for emphasis?>
Now we have to tell which vertices are incident to which edge
    verticesOfEdges := ...
and which edges are incident to which face
    edgesOfFaces := ...
which allows us to use the constructor ..ByDownwardIncidence (for an explanation of this name, see chapter ...[Link]):
    SimplicialSurfaceByDownwardIncidence( verticesOfEdges, edgesOfFaces )
It would be nice if we could reconstruct which edges and faces were problematic. This can easily be done by [footnote: for more about anomalies see chapter ...]
    EdgeAnomalies(surf)
    FaceAnomalies(surf)


--------------
About the chapter ordering:
    
    After the intro we start with "filters" to explain the general structure of this package (mainly to demonstrate PolygonalComplex and its relation to more specific filters).
        Pro: People know what this is all about
        Con: People might not skip and be bored by many different concepts
    
    Then we have "Incidence", the access to the incidence geometry. This is a central chapter. It is after the "filters"-chapter since it is defined for the most general case (polygonal complexes) which the reader might feel confused about if they are not properly introduced.
        Con: One can argue that the incidence geometry by itself motivates the definition of polygonal complex.. Then it should be first. (Although our definition of polygonal complex is more specific than the most general incidence geometry)
        Rebuttal (Pro): The above argument is not completely correct. While it is true that "incidence" feels less technical than "filters" this does not hold if one considers the chapter length - while "incidence" spends a lot of time developing and explaining different ways to present the same information (which is mostly uninteresting), "filters" does focus on a lot of terms but it also develops them with specific examples in play. If it were the case that "incidence" was just a few pages long it could be in front of "filters" to make the focus more clear. As it is it would detract from the main point of the package - the surfaces and complexes.
        Rebuttal (Pro): If we also consider when a linear reader will start skipping it should be clear that the first such point should be after an explanation of the basic package architecture. To show "incidence" first risks that the skipping point is before "filters" which would be a bad development. It would be more plausible to have "filters" first in this case as the information from "incidence" can also be gleamed by a casual reading.

    Then we have "Constructors", a technical chapter about different constructors. Since these differ for different filters, this HAS to be after the "filter"-chapter. Since they also heavily rely on the incidence structure it has to be after the "incidence"-chapter as well. This is therefore the earlies possible position.
        Pro: Having this early means that people can define their surfaces.
        Con: It is quite technical and therefore hinders reading flow.

    Finally we have "Properties" which is a catch-all for all things that are too small to get their own chapter
        -> Elementary properties (Euler Char. etc.)
        -> Connectivity
        -> Orientability
    This has to be after the "incidence"-chapter as most of its calculations and explanations rely on the incidence structure. Furthermore it does not demand a huge amount of attention (it is a conglomeration of random functions) and might not be hindered much by a reduced reading flow after the "constructors"-chapter.

    After this more specialised chapters (like modifcations and embeddings) follow (hopefully).
    They should be behind the others as they are not really needed to work with the core processes.

-------------

TODO This chapter has a technical role but it should not feel technical. This may be achieved by a lot of pictures and non-boring explanation.
Chapter "Different filters" [TODO better name]
    -> Subsections for different filters [TODO: Where do we put IsHomogeneous?]
        - Start with explanation of chapter structure (splitted to make process easier), [Name: "Structure of ??"]
            Put the diagram of the filter structure here, use different colours for different levels, same colours as the section headers
            [Maybe highlight part of the diagram in each section? To give a better feel for the position in the chapter?]
            [Problem: The diagram might confuse new readers (a lot of concepts very quickly) - how can that be circumvented? Maybe make SimplicialComplex and SimplicialSurface bold, the corresponding polygonal ones italic - that makes it easier to distinguish them from the more technical other names. The diagram should give a feeling of structure without confusing people that are not initiated.]
        - Polygonal and simplicial complexes
        - Ramified polygonal and simplicial surfaces [TODO: better name? Apparently PseudoManifold is a fixed term - use it? Alternatively use IsNonBranching, compare wikipedia-entry about pseudo-manifolds]
        - Polygonal and simplicial surfaces
        -> Each subsection explains necessary definitions (some will be there twice - ensure that the surrounding chapter names make it clear to the user in which section they belong!)
        -> The definitions in the explanation of each filter should be very short (referring back to others, new definition should be directly above)


-----------------

Chapter "Access to the incidence geometry"

Chapter "Basic access to the incidence structure" <all methods are exemplified with the standard example (a square that shares an edge with a triangle)>
In polygonal complexes (the most general supported incidence structure, compare ...) all vertices, edges and faces are labelled and we can access the set of all these labels by Vertices, Edges, Faces.
    <put those methods here>
With this labels we can describe the incidence structure as lists of sets. All methods have the form *Of*, like VerticesOfEdges or EdgesOfFaces.
    <put those methods here, with repeated description of their functionality>
    [It is not optimal to repeat the description every time, but if someone jumps to a specific one it is easier this way (especially since the description is not very long in this case)]
    [mention in some methods that there are alternative methods for ordered access]


Chapter "Ordered access to the incidence structure"
In most cases, the basic access functions <link> like VerticesOfFaces are sufficient. But sometimes one might need more detailed information, for example
    -> For a given face f, you need the vertices (or edges) of the face in the order in which they appear on the face [TODO better description]
    -> For a given vertex, you might want to know the order of edges and faces around this vertex
Both of these options are supported [footnote: if you want to know the order of faces around an edge, then this impossible to know purely from the incidence geometry. This is an additional structure "fan" that is added in <link>].

Subsection "Cyclic ordering within a face"
For the cyclic ordering of vertices (or edges) in a face there are two possible representations: As permutations or as lists [explain lists]
    <put those methods here>

Subsection "Cyclic ordering around a vertex"
The ordering of edges and faces around a vertex is much more complicated since it might not even exist.
    <Example>
Nevertheless it is well-defined on the umbrellas around a vertex.   <TODO: How to easily recall the definition? Finish explanation.>
Therefore we can only return a list of those paths for each vertex.
    <put those methods here>

----------------

Chapter "Elementary properties" [Bad name]
    TODO: EulerCharacteristic, VertexCounter etc.


Chapter "Connectivity"
    TODO this is a small chapter -> Put somewhere else?

Chapter "Orientation"
    TODO this is a small chapter -> Put somewhere else?


------------------

Section "Constructors"
    [Explain different kinds of constructors]
    - pre-defined constructors (like Platonic solids)
    - using incidence geometry
        - downward incidence
        - upward incidence
        - vertices in faces
    - giving properties [TODO, using the saved surfaces]
    [Explain for incidence geometry constructors that:
        - there are different types of constructors
        - there are NC-versions
        - there are automatically type-checked versions
        - there are alternative inputs]
    [Explain at start of each subsection what the constructor type of this section is used for.]
    [Structure of the incidence geometry constructors with example downwardIncidence:
        - list all versions for one filter (including NC), argument variations either via two lines or square brackets
        - use a different font (italic?) to show which tests will NOT be made by a NC-version
        - use bold font to make argument names easier to find in the explanation
        - add OPTIONAL in front of the arguments "vertices, edges, faces" that are collapsed into one bullet point
        - make an example
        - other filters (not polygonal complex) refer back to the primary one, like "Does the same as ..., but also guarantees that the result is a simplicial surface")
            - IMPORTANT: They should be visually similar and contain no hidden surprises like "you need to take special care for ..." to make their similarity apparent. This makes it easier to scroll over them to "take the gist".
            - Complementary the main sections should be visually distinguished to catch the floating interest again.
    TODO: can the font-encoding be done in console? Is it enough?
    TODO: This structure is very method-heavy (and repeats quite a lot), therefore very boring to read. Can this be changed?
        This might be reduced by using different examples in the different constructors (for the different situations).
        Focus should be on diversity of examples (with pictures so that scrolling through gives some information)

    DANGER: After this chapter the reader will be in a "glossing over"-mood. The next chapter should not start with many details to make the transition to close reading easier. At the same time it should not be too easy since it should not encourage the reader to skip everything else.


-------------


Chapter "Modification of surfaces"
    TODO

Chapter "Development methods"
    TODO with example of wild simplicial surfaces (before they are introduced?)

Chapter "Anomalies"
    TODO: this seems to be a very short chapter. Should it be added to another chapter?
    YES. This should be part of a chapter about embeddings since this is one of the primary motivations behind anomalies (they are local obstacles for an embedding). Furthermore: If they are not folded together, we can't achieve an embedding.
    ALTERNATIVELY we could explain them as "features" that our definition does not prevent but this does not explain why we dwell on them.
    PROBLEM: There is currently no chapter about embeddings (and also no methods to support them)


Chapters (wild):
    Introduction
    Constructors (?)
    Edge Colouring functions
    Group structure (?)
    Coverings


