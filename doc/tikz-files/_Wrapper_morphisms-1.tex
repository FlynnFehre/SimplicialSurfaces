
\nonstopmode
\documentclass{standalone}

\input{TikZHeader.tex}

\def\pgfsysdriver{pgfsys-tex4ht.def}

\begin{document}
       \begin{tikzpicture}[vertexStyle, edgeStyle, faceStyle]
         \input{Image_PolygonalMorphism_Hexagon.tex}
       \end{tikzpicture}
     </Alt>
 @ExampleSession
 gap> six := SimplicialSurfaceByDownwardIncidence(
 >     [[1,2],[2,3],[3,4],[4,5],[5,6],[6,1],,[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]],
 >     [[1,8,9],[2,9,10],[3,10,11],[4,11,12],[5,12,13],[6,13,8]]);;
 gap> three := SimplicialSurfaceByDownwardIncidence(
 >     [[1,2],[2,3],[3,1],,[1,5],[2,5],[3,5]], [[1,5,6],[2,6,7],[3,7,5]]);;
 gap> mor_6_to_6 := PolygonalIdentityMorphism(six);;
 gap> mor_3_to_3 := PolygonalMorphismByLists(three, three,
 >       [2,3,1,,5], [2,3,1,,6,7,5], [2,3,1]);;
 gap> mor_6_to_3 := PolygonalMorphismByLists(six, three, 
 >    [1,2,3,1,2,3,,5], [1,2,3,1,2,3,,5,6,7,5,6,7], [1,2,3,1,2,3]);;
 gap> comp := CompositionMapping2(mor_3_to_3, mor_6_to_3);;
 gap> VertexMapAsImageList(comp);
 [ 2, 3, 1, 2, 3, 1,, 5 ]
 gap> EdgeMapAsImageList(comp);
 [ 2, 3, 1, 2, 3, 1,, 6, 7, 5, 6, 7, 5 ]
 gap> FaceMapAsImageList(comp);
 [ 2, 3, 1, 2, 3, 1 ]
 gap> CompositionMapping2(mor_6_to_3, mor_6_to_6) = mor_6_to_3;
 true
 gap> CompositionMapping(mor_3_to_3, mor_6_to_3, mor_6_to_6) = comp;
 true
 @EndExampleSession

   </Description>
 </ManSection>



 <ManSection Label="InversePolygonalMorphism">
   <Attr Name="InversePolygonalMorphism" Arg="isoMor" 
      Label="for IsPolygonalMorphism and IsBijective"
      Comm="Construct the inverse polygonal morphism from a bijective polygonal morphism"/>
   <Oper Name="Inverse" Arg="autoMor" 
      Label="for a bijective polygonal morphisms with identical source and range"
      Comm="Construct the inverse polygonal morphism from a bijective polygonal morphism with identical source and range"/>
   <Attr Name="InverseGeneralMapping" Arg="isoMor" 
      Label="for a bijective polygonal morphism"
      Comm="Construct the inverse polygonal morphism from a bijective polygonal morphism"/>
   <Returns>A polygonal morphism</Returns>
   <Description>
     Given a bijective polygonal morphism, one can define its inverse,
     i.e. a polygonal morphism, in which <K>SourceComplex</K>
     (<Ref Subsect="SourceComplex"/>) and <K>RangeComplex</K>
     (<Ref Subsect="RangeComplex"/>) are switched.
     
     Due to the way in which GAP handles inverses and mappings (compare the
     introduction of section 
     <Ref Sect="Arithmetic Operations for General Mapping" BookName="Reference"/>), 
     the different 
     methods perform subtly different tasks:
     * <K>InversePolygonalMorphism</K>(<A>isoMor</A>) 
       constructs the expected inverse
       map, from <K>RangeComplex</K>(<A>isoMor</A>) to
       <K>SourceComplex</K>(<A>isoMor</A>).
     * <K>Inverse</K>(<A>autoMor</A>) <E>only</E> constructs this inverse, if 
       <K>SourceComplex</K>(<A>autoMor</A>) and
       <K>RangeComplex</K>(<A>autoMor</A>) coincide.
     * <K>InverseGeneralMapping</K> does the same
       as <K>InversePolygonalMorphism</K>, but might be subject to future
       change, if inverses are defined for non-bijective morphisms in
       the future.

     All of the methods throw errors if their requirements are not met.

     To illustrate, we use a relabelling of a five-umbrella.
      <Alt Only="HTML">
 &lt;br>&lt;img src="./images/_Wrapper_Image_PolygonalMorphism_FiveUmbrella-1.svg"> &lt;/img> &lt;br>
end{document}